# Ответы

## 1. Операционная система (ОС). Определение, состав, основные функции
Операционная система, сокр. ОС (англ. operating system, OS) — комплекс взаимосвязанных программ, предназначенных для управления ресурсами компьютера и организации взаимодействия с пользователем.
Основные функции ОС:
    • Управление устройствами компьютера (ресурсами), т.е. согласованная работа всех аппаратных средств ПК: стандартизованный доступ к периферийным устройствам, управление оперативной памятью и др.
    • Управление процессами, т.е. выполнение программ и их взаимодействие с устройствами компьютера.
    • Управление доступом к данным на энергонезависимых носителях (таких как жесткий диск, компакт-диск и т.д.), как правило, с помощью файловой системы.
    • Ведение файловой структуры.пользовательский интерфейс, т.е. диалог с пользователем.
    • Параллельное или псевдопараллельное выполнение задач (многозадачность).
    • Взаимодействие между процессами: обмен данными, взаимная синхронизация.
    • Защита самой системы, а также пользовательских данных и программ от злонамеренных действий пользователей или приложений.
    • Разграничение прав доступа и многопользовательский режим работы (аутентификация, авторизация).
Состав:
Наиболее общим подходом к структуризации операционной системы является разделение всех ее модулей на две группы:
    • Ядро – это модули, выполняющие основные функции ОС.
    • Вспомогательные модули, выполняющие вспомогательные функции ОС. Одним из определяющих свойств ядра является работа в привилегированном режиме.

    • Программный модуль, управляющий файловой системой.
    • Командный процессор, выполняющий команды пользователя.
    • Драйверы устройств.
    • Программные модули, обеспечивающие графический пользовательский интерфейс.
    • Сервисные программы.
    • Справочная система.
Драйвер устройства (device driver) – специальная программа, обеспечивающая управление работой устройств и согласование информационного обмена с другими устройствами.
Командный процессор (command processor) – специальная программа, которая запрашивает у пользователя команды и выполняет их (интерпретатор программ).

## 2. Классификация ОС

Существует несколько схем классификации операционных систем. Ниже приведена классификация по некоторым признакам с точки зрения пользователя.
По количеству одновременно работающих пользователей:
    • Однопользовательские ОС позволяют работать на компьютере только одному человеку.
    • Многопользовательские ОС поддерживают одновременную работу на ЭМВ нескольких пользователей за различными терминалами.
По числу процессов, одновременно выполняемых под управлением системы:
    • Однозадачные ОС поддерживают выполнение только одной программы в отдельный момент времени, то есть позволяют запустить одну программу в основном режиме.
    • Многозадачные ОС (мультизадачные) поддерживают параллельное выполнение нескольких программ, существующих в рамках одной вычислительной системы на некотором отрезке времени, то есть позволяют запустить одновременно несколько программ, которые будут работать параллельно, не мешая друг другу.
По количеству поддерживаемых процессоров (однопроцессорные, многопроцессорные):
    • Многопроцессорные ОС поддерживают режим распределения ресурсов нескольких процессоров для решения той или иной задачи. При многопроцессорном режиме работы два или несколько соединенных и примерно равных по характеристикам процессора совместно выполняют один или несколько процессов (программ или наборов команд). Цель такого режима – увеличение быстродействия или вычислительных возможностей.
Многопроцессорные ОС разделяют на симметричные и асимметричные. В симметричных ОС на каждом процессоре функционирует одно и то же ядро, и задача может быть выполнена на любом процессоре, то есть обработка полностью децентрализована. При этом каждому из процессоров доступна вся память.
В асимметричных ОС процессоры неравноправны. Обычно существует главный процессор (master) и подчиненные (slave), загрузку и характер работы которых определяет главный процессор.
    • По типу доступа пользователя к ЭВМ (с пакетной обработкой, с разделением времени, реального времени):
    • ОС пакетной обработки: в них  из программ, подлежащих выполнению, формируется пакет (набор) заданий, вводимых в ЭВМ и выполняемых в порядке очередности с возможным учетом приоритетности.
    • ОС разделения времени обеспечивают одновременный диалоговый (интерактивный) режим доступа к ЭВМ нескольких пользователей на разных терминалах, которым по очереди выделяются ресурсы машины, что координируется операционной системой в соответствии с заданной дисциплиной обслуживания. Каждой программе, находящейся в оперативной памяти и готовой к исполнению, выделяется для исполнения фиксированный, задаваемый в соответствии с приоритетом пользователя интервал времени (интервал мультиплексирования). Если программа не выполнена до конца за этот интервал, ее исполнение принудительно прерывается, и программа переводится в конец очереди. Из начала очереди извлекается следующая программа, которая исполняется в течение соответствующего интервала мультиплексирования, затем поступает в конец очереди и т.д. в соответствии с циклическим алгоритмом.
    • ОС реального времени обеспечивают  определенное гарантированное время ответа машины на запрос пользователя с управлением им какими-либо внешними по отношению к ЭВМ событиями, процессами или объектами. При таком режиме ЭВМ управляет некоторым внешним процессом, обрабатывая данные и информацию, непосредственно поступающую от объекта управления.
По разрядности кода операционной системы: восьмиразрядные, шестнадцатиразрядные, тридцатидвухразрядные, шестидесяти четырехразрядные:
    • Разрядность кода – это разрядность используемых аппаратных средств (например, использование 32-разрядных регистров для процессоров). Подразумевается, что разрядность ОС не может превышать разрядности процессора.
По типу интерфейса (командные (текстовые), объектно-ориентированные (как, правило, графические):
    • Пользовательский интерфейс – это программные и аппаратные средства взаимодействия пользователя с программой или ЭВМ. Пользовательский интерфейс бывает командным и объектно-ориентированным.
    • Командный интерфейс предполагает ввод пользователем команд с клавиатуры при выполнении действий по управлению ресурсами компьютера. При этой технологии в качестве единственного способа ввода информации от человека к компьютеру служит клавиатура, а компьютер выводит информацию человеку с помощью монитора. Эту комбинацию (монитор + клавиатура) стали называть консолью.

## 3. Поколения ОС

ервое поколение (1945 - 1955): Первые ЭВМ были построены на основе электронных ламп. Они не были предназначены для практических целей. Одни и те же люди проектировали эти машины, писали для них программы и их эксплуатировали. Первые электронные ЭВМ не имели ОС. Функции ОС включались в состав прикладных программ.
Использовались механические реле, позже они были заменены на электронные лампы.
>Не были известны языки программирования.
>Никто не слышал об операционных системах.
>Носителями исходной информации стали перфокарты.
Второе поколение (1955 - 1965): второе поколение ОС было создано для ЭВМ, построенных на полупроводниковых транзисторах. Такие ЭВМ могли работать более длительное время без ошибок и сбоев. Машинное время их стоило очень дорого, поэтому одной из основных функций первых ОС была организация пакетного режима работы. Этот режим позволял сокращать время простоя при переходе от решения одной задачи к другой.
>Транзисторы заменили электронные лампы.
>Появились языки программирования Ассемблер и Фортран.
>Общепринятым решением стала система пакетной обработки.
Третье поколение (1965 - 1980):Это поколение ОС было связано с ЭВМ, построенными на основе модулей и первых интегральных схем. Стали появляться ЭВМ с несколькими CPU. ОС для таких машин должны были обладать способностями управлять работой нескольких процессоров, иметь многозадачный режим работы, а так же, обладать возможностью работы с несколькими пользователями. Это были системы коллективного пользования.
На многопроцессорной ЭВМ задача разбивалась на несколько частей, и эти часть параллельно выполнялись на отдельных процессорах, что позволяло резко увеличить вычислительную мощность. Мультипрограммный режим работы заключался в том, что в память ЭВМ загружалось одновременно несколько задач, ОС при этом выделяла процессор каждой задаче на определенное время, автоматически переключая его между всеми задачами.
Режим коллективного пользования заключался в том, что к вычислит.машине подключалось несколько терминалов (монитор и клавиатура), за которыми работали отдельные пользователи. ОС с большей скоростью переключала терминалы, и у каждого пользователя создавалось впечатление, что он один работает с ВМ..
Создана операционная система OS/360. 
Позже появились:
MULTICS (MULTiplexed Information and Computing Service - мультиплексная информационная и вычислительная служба);
UNIX (для PDP-7), ставшая популярная в академическом мире, в пправительственных управлениях и во многих компаниях. Система имела две версии: System V (разработчик корпорация AT&T) и BSD (Калифорнийский университет). Существует стандарт системы UNIX, называемый POSIX. Стандарт определяет минимальный интерфейс системного вызова, который должен поддерживать совместимые системы UNIX.
MINIX (1987 год) - маленький клон системы UNIX для образовательных целей
Четвертое поколение (с 1980 года по наши дни): Это поколение связано в первую очередь с ЭВМ на основе больших и сверхбольших интегральных микросхем. Основными классами ЭВМ этого поколения являются ЭВМ общего пользования, мини и микро ЭВМ, персональные ЭВМ и суперЭВМ (многопроцессорные).
Это поколение включает в себя все основные черты ОС предыдущих поколений, а так же имеют следующие особенности:
Управление работой сетей ЭВМ.
Управление работой сложных многопроцессорных вычислительных комплексов.
Появление ОС ПК.
ОС начали использовать «дружественный» интерфейс, т.е. ОС строятся в расчете на не подготовленных или малоподготовленных пользователей.

## 4. Ресурсы в ОС

Понятие ресурса явл. одним из основных при рассмотрении ОС. Термин ресурс обычно применяется по отношению к повторно использующимся, относительно стабильным и часто недостающим объектам, которые запрашиваются, используются и освобождаются процессами в период их активности. Ресурсы могут быть разделяемыми, когда несколько процессов могут использовать их одновременно (в один и тот же момент времени) или параллельно (в течение некоторого времени процессы используют ресурс попеременно) и неразделяемыми. Основные виды ресурсов.
1. Процессорное время
2. Память. Оперативная память может быть разделена одновременным способом, в этом сл-е в памяти может располагаться одновременно несколько процессов, либо целиком, либо текущие фрагменты; и попеременно – в разные моменты времени она может предоставляться для различных вычислительных процессов. В каждый конкретный момент времени процессор при выполнении вычислений обращается опять к ограниченному числу ячеек оперативной памяти. С этой точки зрения полезно разделять память для возможно большего числа идущих параллельно процессов. С другой стороны, как правило, чем больше оперативной памяти может быть свободно для конкретного текущего процесса, тем лучше условия его выполнения.
3. Программные модули. Системные программные ресурсы. Могут быть разделены между выполняющимися процессами. Программные модули могут быть однократно исполняемыми (исполняются правильно только один раз, и являются неделимыми ресурсами, более того их вообще можно не рассматривать как ресурс системы. Такие модули используются, как правило, при загрузке системы.) и многократно исполняемыми. Многократно исполняемые программные модули могут быть непривилегированные, привилегированные и реентерабельные.
Информационные ресурсы могут существовать как в виде переменных, находящихся в оперативно памяти, так и в виде файлов. Если процессы могут использовать информационные ресурсы только для чтения, то такие информационные ресурсы можно разделять. Если же процессы могут изменять информационные ресурсы, то необходимо каким-то образом организовывать работу с такими данными.
Задачи управления ресурсами.
Управление ресурсами включает решение следующих общих, не зависящих от типа ресурса задач:
планирование ресурса — то есть определение, какому процессу, когда и в каком количестве (если ресурс может выделяться частями) следует выделить данный ресурс;

удовлетворение запросов на ресурсы;
отслеживание состояния и учет использования ресурса — то есть поддержание оперативной информации о том, занят или свободен ресурс и какая доля ресурса уже распределена;
разрешение конфликтов между процессами.
Для решения этих общих задач управления ресурсами разные ОС используют различные алгоритмы. Задача организации эффективного совместного использования ресурсов несколькими процессами является весьма сложной, и сложность эта порождается в основном случайным характером возникновения запросов на потребление ресурсов. управление ресурсами составляет важную часть функций любой операционной системы
Слоеные системы хорошо реализуются. При использовании операций нижнего слоя не нужно знать, как они реализованы, нужно лишь понимать, что они делают. Слоеные системы хорошо тестируются. Отладка начинается с нижнего слоя и проводится послойно. При возникновении ошибки мы можем быть уверены, что она находится в тестируемом слое. Слоеные системы хорошо модифицируются. При необходимости можно заменить лишь один слой, не трогая остальные. Но слоеные системы сложны для разработки: тяжело правильно определить порядок слоев и что к какому слою относится. Слоеные системы менее эффективны, чем монолитные. Так, например, для выполнения операций ввода-вывода программе пользователя придется последовательно проходить все слои от верхнего до нижнего.

## 5. Процесс. Определение, состояния процесса. Операции с процессами

Процесс – основное понятие ОС. Операционная система создает процесс, когда пользователь запускает программу на выполнение. ОС руководит всеми процессами в системе, а именно:
- Приостанавливает выполнение одних процессов;
- Активизирует другие процессы;
- Создает новые процессы;
- Уничтожает процессы, которые уже выполнились, или не могут быть выполнены по каким – либо причинам ( ошибкам ).
Программа на стадии выполнения и процесс – это не одно и то же, для каждого процесса ОС создает набор данных, который называется средой выполнения процесса, который включает:
- Исполнимый файл ( код программы );
- Начальные исходные данные;
- Имя текущего каталога;
- Стандартные файлы ввода – вывода;
- Файлы кодов ошибок;
- Переменные окружения и др.
Процесс обязательно находится в одном из возможных состояний и может быть переведен из одного состояния в другое.
1.Работоспособный( runnable ). – в данный момент выполняет какие – либо действия или стоит в очереди на получения кванта процессорного времени. Обозначается символом R
2.Ожидающий( спящий, sleeping ) – возникает после того, как процесс инициирует системную операцию , окончания которой он должен дождаться. Например: операции ввода – вывода, завершение дочернего процесса.
Обозначается символом S
3.Остановленный( stopped ) – процесс может быть остановлен: администратором,
программой – отладчиком в контрольной точке;
при фоновом режиме выполнения при попытке ввести данные с клавиатуры;
Обозначается символом T
4.Завершающийся( zombie ) – ожидает завершения всех дочерних процессов, после того, как родительский процесс завершен. После завершения процесса информация о нем удаляется из таблицы состояния процессов.
Обозначается символом Z
Существует два режима исполнения процессов оперативный и фоновый.
В оперативном режиме ИК переходит в режим ожидания завершения процесса, или всех дочерних процессов ( в случае конвейера ), а не режим ввода следующей команды пользователя.
В фоновом режиме ИК сразу переходит к выполнению следующей команды ( в случае конвейера) или выводит приглашение системы для ввода следующей команды, т.е. процесс выполняется без участия пользователя, во время выполнения других процессов. Для запуска процесса в фоновом режиме выполнения в конце команды или конвейера следует поставить символ &.
Операции над процессами производимые операционной системой удобно объединить в пары:
- создание процесса – завершение процесса;
- приостановка процесса – запуск процесса;
- блокирование процесса – разблокирование процесса;
- изменение приоритета процесса.
Операции создание и завершение процесса являются одноразовыми, так как применяются к процессу не более одного раза (некоторые системные процессы при работе вычислительной системы не завершаются никогда). Остальные операции, связанные с изменением состояния процессов, являются многоразовыми. Одноразовые операции приводят к изменению количества процессов, находящихся под управлением операционной системы и всегда связаны с выделением или освобождением определенных ресурсов. Многоразовые операции не приводят к изменению количества процессов и не обязаны быть связанными с выделением или освобождением ресурсов.
Одноразовая операция создание процесса. Сложный жизненный путь процесса начинается с его рождения. В простых системах все процессы могут порождаться на этапе старта системы, в более сложных системах – создаваться динамически по мере необходимости. Инициатором рождения процесса после старта операционной системы может быть процесс пользователя, совершивший специальный системный вызов, либо процесс созданный самой операционной системой. Процесс, создавший новый процесс, называют процессом родителем, а созданный процесс –потомком (дочерним процессом или ребенком). Выделяют четыре основных события, которые приводят к созданию новых процессов:
- загрузка (инициализация) системы;
- выполнение изданного работающим процессом системного запроса на создание процесса;
- запрос пользователя на создание процесса;
- инициирование пакетного задания.

## 6. Диаграмма состояний процессов

<img src=images/Q6.png width=100%>

Представленная на рисунке диаграмма состояний процесса может отличаться от принятой в конкретной операционной системе. Но, тем не менее, она отражает типичный жизненный цикл процесса: рождение – готовность – выполнение – уничтожение.
При рождении процесс получает в свое распоряжение адресное пространство, в которое загружается программный код процесса. Ему выделяется стек и системные ресурсы, устанавливается начальное значение программного счетчика процесса и т.д.
Всякий новый процесс, появляющийся в системе, попадает в состояние готовность. Операционная система, пользуясь алгоритмом планирования, выбирает один из готовых процессов и переводит его в состояние исполнение. В этом состоянии происходит непосредственное выполнение программного кода процесса. Выйти из этого состояния процесс может по следующим причинам:
    • операционная система прекращает выполнение процесса;
    • процесс не может продолжать свою работу, пока не произойдет некоторое событие. В этом случае операционная система переводит процесс в состояние ожидания; После того, как событие произошло, операционная система возвращает процесс в состояние готовность.
    • в результате возникновения прерывания в вычислительной системе (например, от таймера по истечении предусмотренного времени выполнения) операционная система возвращает процесс в состояние готовность.
После завершения своей деятельности процесс переходит в состояние уничтожение.
Процесс завершается одним из следующих четырех способов:
1. Нормальное завершение (добровольное).
2. Завершение вследствие ошибки (добровольное).
3. Завершение вследствие фатальной ошибки (принудительное).
4. Уничтожение другим процессом (принудительное).

## 7. Алгоритмы планирования с одной очередью

Планировщик процессов планирует различные процессы, которые должны быть назначены ЦПУ на основе определенных алгоритмов планирования. Существует шесть популярных алгоритмов планирования процессов
    • Планирование «первым пришел – первым обслужен» (FCFS)
    • Планирование Shortest-Job-Next (SJN)
    • Приоритетное планирование
    • Самое короткое оставшееся время
    • Круглый Робин (RR) Планирование
    • Планирование многоуровневых очередей
First Come First Serve (FCFS)
    • Задания выполняются в порядке поступления.
    • Это не упреждающий, упреждающий алгоритм планирования.
    • Легко понять и реализовать.
    • Его реализация основана на очереди FIFO.
    • Низкая производительность, так как среднее время ожидания велико.
Кратчайшая работа следующая (SJN)
    • Это также называется первой короткой работой , или SJF
    • Это не упреждающий, упреждающий алгоритм планирования.
    • Лучший подход для минимизации времени ожидания.
    • Легко реализовать в пакетных системах, где необходимое время процессора известно заранее.
    • Невозможно реализовать в интерактивных системах, где необходимое время ЦП неизвестно.
    • Процессор должен заранее знать, сколько времени займет процесс.
Приоритетное планирование
    • Приоритетное планирование – это алгоритм без вытеснения и один из самых распространенных алгоритмов планирования в пакетных системах.
    • Каждому процессу назначается приоритет. Процесс с наивысшим приоритетом должен выполняться первым и так далее.
    • Процессы с одинаковым приоритетом выполняются по принципу «первым пришел – первым обслужен».
    • Приоритет может быть решен на основе требований к памяти, времени или любых других ресурсов.
Самое короткое оставшееся время
    • Наименьшее оставшееся время (SRT) является преимущественной версией алгоритма SJN.
    • Процессор выделяется для задания, наиболее близкого к завершению, но ему может предшествовать более новое готовое задание с более коротким временем до завершения.
    • Невозможно реализовать в интерактивных системах, где необходимое время ЦП неизвестно.
    • Он часто используется в пакетных средах, где короткие задания должны отдавать предпочтение.
Круглый Робин Планирование
    • Round Robin – это алгоритм планирования вытесняющих процессов.
    • Каждому процессу предоставляется определенное время для выполнения, оно называется квантом .
    • Как только процесс выполняется в течение заданного периода времени, он прерывается, и другой процесс выполняется в течение заданного периода времени.
    • Переключение контекста используется для сохранения состояний вытесненных процессов.

## 8. Виды организации реальной оперативной памяти

    • Round Robin – это алгоритм планирования вытесняющих процессов.
    • Каждому процессу предоставляется определенное время для выполнения, оно называется квантом .
    • Как только процесс выполняется в течение заданного периода времени, он прерывается, и другой процесс выполняется в течение заданного периода времени.
    • Переключение контекста используется для сохранения состояний вытесненных процессов.
    8. Виды организации реальной оперативной памяти.
Существуют 4 вида организации реальной памяти:
    1. Однопрограммная организация памяти с выделением непрерывной области одному пользователю. Это самая простая организация, которая использовалась на первых ЭВМ и на микро-ЭВМ, а также и на первых персональных компьютерах (PC) (рисунок 5.2).
Достоинства: простота защиты оперативной памяти. Для защиты требуется пара регистров, определяющих границы доступа ОП.
Недостатки: Простаивает ЦП, а, следовательно, и ОП, и устройства ввода/вывода. Неэффективное использование ЭВМ даже при наличии потока заданий, когда задания формируются в пакеты (режим PCP для ЕС ЭВМ).
    2. Мультипрограммная организация с фиксированными разделами. ОП при загрузке ОС статически разбивается на ряд разделов фиксированного размера, в каждом из которых может выполняться одно задание (режим MFT OC в ЕС ЭВМ, MP?? фирмы Digital Research для 8 и 16 – разрядных процессоров Intel 8080, 8086).
Задание (программа) может помещаться в любой свободный раздел, размер которого это допускает. Защита памяти осуществляется парой регистров для каждого раздела ОП.
Достоинства: большая загрузка ЦП и повышение пропускной способности.
Недостатки:
1) Внешняя фрагментация, которая выражается в недостаточности разделов для больших программ, что требует перезагрузки ОС для назначения больших разделов.
2) Внутренняя фрагментация, при которой совокупная неиспользованная память может быть достаточной для выполнения программы, но разделена на несвязные участки и не может быть задействована для размещения процессов и данных.
3.Мультипрограммированная организация с переменными разделами, при которой ОП разделяется динамически между процессами по запросам заданий (программ) пользователей.
 Области памяти выделяются непрерывные из участков свободной памяти в соответствии с реализованными стратегиями размещения. При окончании заданий соседние свободные участки ОП объединяются. Защита памяти аналогичная режиму с фиксированными разделами.
Достоинства: повышается уровень мультипрограммирования, исчезает внутренняя фрагментация (выделяется памяти столько, сколько требуется).
Недостатки: внешняя фрагментация памяти - образование неиспользованных участков в целом может давать большие потери объема и мультипрограммирования.
4. Страничная организация памяти реализует концепцию несвязного распределения памяти ЭВМ и означает
а) разделение ОП ЭВМ на блоки фиксированной длины размером от 1 до 4 Kb
б) разделение адресного пространства программы загрузчиком на страницы фиксированного размера, равного длине блока;
в) динамически поблочно выдается память программам в любом месте ЭВМ;
г) аппаратная поддержка соответствия номеров блоков ОП ЭВМ и страниц процесса по соответствующей таблице отображения страниц.
Достоинства:
1.Отсутствие внешней фрагментации (достаточно разделов для больших программ).
2.Внутренняя фрагментация ограничена размером блока ОП ЭВМ < 1 -4 кб.
Общий итог развития форм организации реальной ОП - практически полная ликвидация фрагментации.

## 9. Методы управления реальной оперативной памятью

Для эффективного использования ОП необходимо определить стратегию управления памятью. ОС постоянно приходится решать задачу: когда, куда и за счет кого ввести в ОП процесс и данные. Существует три стратегии управления ОП:
Стратегия выборки - определяет, когда разместить в ОП очередной блок программы или данных.
а) выборка по запросу (требованию), когда очередной блок загружается по требованию процесса. При такой реализации невозможно в общем случае определить передачу управления в программе (настройка адресов должна быть выполнена после загрузки);
б) упреждающая выборка, основанная на свойствах последовательного выполнения программы и локальности циклов. В настоящее время наиболее употребляемая стратегия.
Стратегия размещения, определяющая, куда помещать поступающую программу.
а) "первый подходящий" участок (эффективность по времени размещения);
б) "наиболее подходящий" участок (эффективность по объему);
в) "наименее подходящий" - странная стратегия со следующей аргументацией: после размещения процесса в больший свободный участок, оставшееся место также велико и может быть достаточно для размещения еще одной программы. Псевдоэффективность по мультипрограммированию.
Стратегия замещения, определяющая какой блок/сегмент программы или данных следует вытолкнуть из ОП для освобождения места для более приоритетных программ (в системах со свопингом). Естественно, что организация памяти тесно связана с мощностью ЦП, объемом ОП и режимом мультипрограммирования

## 10. Назначение и организация оверлейного режима

ак как размер логического адресного пространства процесса может быть больше, чем размер выделенного ему раздела (или больше, чем размер самого большого раздела), иногда используется техника, называемая оверлей (overlay) или организация структуры с перекрытием. Основная идея – держать в памяти только те инструкции программы, которые нужны в данный момент.
Потребность в таком способе загрузки появляется, если логическое адресное пространство системы мало, например 1 Мбайт (MS-DOS) или даже всего 64 Кбайта (PDP-11), а программа относительно велика.
Организация структуры с перекрытием. Можно поочередно загружать в память ветви A-B, A-C-D и A-C-E программы

<img src=images/Q10.png width=100%>

Коды ветвей оверлейной структуры программы находятся на диске как абсолютные образы памяти и считываются драйвером оверлеев при необходимости. Для описания оверлейной структуры обычно используется специальный несложный язык (overlay description language). Совокупность файлов исполняемой программы дополняется файлом (обычно с расширением .odl), описывающим дерево вызовов внутри программы. Для примера, приведенного на рисунке, текст этого файла может выглядеть так:
A-(B,C)
C-(D,E)
Синтаксис подобного файла может распознаваться загрузчиком. Привязка к физической памяти происходит в момент очередной загрузки одной из ветвей программы.
Тщательное проектирование оверлейной структуры отнимает много времени и требует знания устройства программы, ее кода, данных и языка описания оверлейной структуры. По этой причине применение оверлеев ограничено компьютерами с небольшим логическим адресным пространством.

## 11. Назначение и организация режима свопинга

Имея дело с пакетными системами, можно обходиться фиксированными разделами и не использовать ничего более сложного. В системах с разделением времени возможна ситуация, когда память не в состоянии содержать все пользовательские процессы. Приходится прибегать к свопингу (swapping) – перемещению процессов из главной памяти на диск и обратно целиком. Частичная выгрузка процессов на диск осуществляется в системах со страничной организацией (paging).
Выгруженный процесс может быть возвращен в то же самое адресное пространство или в другое. Это ограничение диктуется методом связывания. Для схемы связывания на этапе выполнения можно загрузить процесс в другое место памяти.
Свопинг не имеет непосредственного отношения к управлению памятью, скорее он связан с подсистемой планирования процессов. Очевидно, что свопинг увеличивает время переключения контекста. Время выгрузки может быть сокращено за счет организации специально отведенного пространства на диске (раздел для свопинга). Обмен с диском при этом осуществляется блоками большего размера, то есть быстрее, чем через стандартную файловую систему. Во многих версиях Unix свопинг начинает работать только тогда, когда возникает необходимость в снижении загрузки системы.

## 12. Назначение и принципы организации виртуальной памяти

Виртуальная память — это концепция, которая позволяет уйти от использования физических адресов, используя вместо них виртуальные, и это даёт ряд преимуществ:

    • Расширение реального адресного пространства. Часть виртуальной памяти может быть вытеснена на жёсткий диск, и это позволяет программам использовать больше оперативной памяти, чем есть на самом деле.
    • Создание изолированных адресных пространств для различных процессов, что повышает безопасность системы, а также решает проблему привязанности программы к определённым адресам памяти.
    • Задание различных свойств для разных участков участков памяти. Например, может существовать неизменяемый участок памяти, видный нескольким процессам.
При этом вся виртуальная память делится на участки памяти постоянного размера, называемые страницами.
Виртуальная память (Virtual Memory) представляет собой программно-аппаратное средство расширения пространства памяти, предоставляемой программе в качестве оперативной. Эта память физически реализуется в оперативной и дисковой памяти под управлением соответствующей операционной системы. Требуется так организовать работу процессора с дисковой памяти, чтобы возникала иллюзия работы только с оперативной памятью.
Виртуальное пространство памяти разбито на страницы фиксированного размера, а в физической оперативной памяти в каждый момент времени присутствует только часть из них. Остальные страницы хранятся на диске, откуда операционная система может "подкачать" их в физическую память, предварительно выгрузив на диск часть неиспользуемых в данный момент модифицированных страниц. Обращение процессора к ячейке виртуальной памяти, присутствующей в физической памяти, происходит обычным способом. Если же затребованная область в данный момент не отображена в физической памяти, процессор вырабатывает исключение (внутреннее прерывание), по которому операционная система программно организует замещение страниц, называемое свопингом (Swapping). Виртуальную память поддерживают процессоры, работающие в защищенном режиме, начиная с 80286, но реально ее широко стали использовать только в операционных системах и оболочках для 32-разрядных процессоров (80386 и далее). Максимальный объем виртуальной памяти определяется размером файла подкачки (Swap File), выделяемом на жестком диске для нужд виртуальной памяти.
В многопрограммном режиме работы компьютер выполняет множество задач, каждой из которых отводится свое адресное пространство в оперативной памяти. Поэтому необходим механизм разделения небольшой физической памяти между различными задачами. Виртуальная память делит физическую память на блоки и распределяет их между различными задачами. При этом обеспечивается иллюзия того, что каждая задача и в самом деле исполняется на машине с огромным количеством реальной оперативной памяти.
Системы виртуальной памяти можно разделить на два класса: системы с фиксированным размером блоков, называемых страницами, и системы с переменным размером блоков, называемых сегментами.
Очевидно, что для реализации возможности автоматического выделения памяти каждой задаче в процессе ее выполнения (динамически), необходимо обеспечить эту возможность аппаратно. Для того, чтобы программа могла действительно воспользоваться виртуальной памятью (иллюзией очень большого количества реальной оперативной памяти) требуется еще и поддержка программного обеспечения. Задача управления виртуальной памятью возлагается на операционную систему. Различные операционные системы по разному решают вопросы управления памятью. Попробуем получить общее представление о работе виртуальной памяти.
Механизмы управления памятью решают две главные задачи:
    • Трансляцию виртуального адресного пространства процесса на физическую память. Это позволяет ссылаться на конкретные адреса физической памяти потокам процесса, работающим в виртуальном адресном пространстве.
    • Подкачку части содержимого памяти с диска, когда потоки пытаются задействовать больший объем физической памяти, чем тот, который имеется в наличии, и выгрузку страниц обратно по мере необходимости.

## 13. Страничная организаци виртуальной памяти

Виртуальная память может использовать страничную и сегментную адресации. При использовании страничной адресации в специальные сегментные регистры процессора загружаются селекторы, базовые адреса которых равны нулю, а размер сегмента составляет 4 Гбайта. И хотя для микропроцессора механизм сегментной адресации продолжает работать, основным механизмом формирования адреса становится страничная адресация. Такая модель памяти и называется плоской (FLAT). Логическая адресация в такой модели определяется только смещением. Для программиста область памяти, адресуемая смещением, находится в полном распоряжении. Это и есть логический адрес, который преобразуется операционной системой в физический.
Страничный механизм является составной частью системы виртуальной памяти.
Страничное преобразование позволяет сохранить линейность адресов для прикладных программ, несмотря на то, что их работающие страницы располагаются в оперативной памяти в произвольном порядке. Программы работают со своим адресным пространством, так словно у каждой из них есть своя собственная линейно адресуемая оперативная память.
Применительно к виртуальной памяти различают три адресных пространства: логическое, линейное и физическое.
Логический адрес формируется при обращении к виртуальному адресному пространству.
Блок сегментации транслирует логический адрес в линейный.
Физический адрес образуется после преобразования линейного адреса блоком страничной переадресации.
И так, выполняемая программа загружается в оперативную память не целиком, а отдельными страницами (рис1.). Страница с которой работает процессор называется активной.
В случае динамического распределения памяти (по запросу программы), адрес содержит номер виртуальной страницы и номер слова в странице. Для защиты памяти от записи и чтения другими процессами необходима соответствующая схема трансляции адреса, которая разрешает доступ к данной области памяти только определенной задаче.
Соответствие между физическим положением данных в памяти и адресом существует только для основной (оперативной) памяти, виртуальная память использует всю иерархическую структуру памяти как непрерывно адресуемую.

## 14. Методы управления виртуальной памятью

Все методы управления памятью имеют одну и ту же цель — хранить в памяти мультипрограммную смесь, необходимую для мультипрограммирования. Рассмотренные ранее методы предполагали, что вся программа перед выполнением должна быть размещена в основной памяти. Виртуальная память — это технология, которая позволяет выполнять процесс, который может только частично располагаться в основной памяти. Таким образом, виртуальная память позволяет выполнять программы, размеры которых превышают размеры физического адресного пространства.
Перемещение страниц по запросу (demand paging). Виртуальная память чаще всего реализуется на базе страничной организации памяти, совмещенной со свопингом страниц.
Свопингу подвергаются только те страницы, которые необходимы процессору. Таким образом, перемещение страниц по запросу означает:
• программа может выполняться CPU, когда часть страниц находится в основной памяти, а часть — во внешней;
• в процессе выполнения новая страница не перемещается в основную память до тех пор, пока в ней не возникла необходимость.
Для учета распределения страниц между внешней и основной памятью каждая строка таблицы страниц дополняется битом местонахождения страницы (valid/invalid bit).
В том случае, если процессор пытается использовать страницу, помеченную значением invalid, возникает событие, называемое страничная недостаточность (paging fault).
Замещение страниц. В процессе обработки страничной недостаточности операционная система может обнаружить, что все страничные рамки основной памяти заняты и, следовательно, невозможно загрузить требуемую страницу. В этом случае возможны следующие режимы: приостановка прерванного процесса, уменьшение на единицу количества процессов мультипрограммной смеси для освобождения всех ею занимаемых страничных рамок, использование метода замещения страниц.
Метод замещения страниц состоит в том, что в основной памяти выбирается наименее важная/используемая страница, называется страница-жертва (victim page), которая временно перемещается в пространство свопинга, а на ее место загружается страница, вызываемая страничной недостаточностью.

## 15. Организация внешней

Внешняя память. По аналогии с отмеченными выше физическими свойствами внутренней памяти, свойства внешней памяти описываются так:

· вешняя память энергонезависима, т.е. информация в ней сохраняется независимо от того, включен или выключен компьютер, вставлен носитель в компьютер или лежит на столе;

· внешняя память — медленная по сравнению с оперативной; в порядке возрастания скорости чтения/записи информации, устройства внешней памяти располагаются так: магнитные ленты – магнитные диски – оптические диски;

· объем информации, помещающейся во внешней памяти больше, чем во внутренней; а с учетом возможности смены носителей неограничен.

## 16. Структура жесткого диска

Физическая структура: магнитная поверхность каждого диска разделена на концентрические дорожки, которые в свою очередь делятся на отрезки-сектора. Все пространство жесткого диска разделено на секторы емкостью 512 байт. Дисков может быть несколько, поэтому наряду с дорожками и секторами существует еще и третье деление: на цилиндры. Цилиндр – это сумма всех совпадающих друг с другом дорожек по вертикали, по всем рабочим поверхностям.
Логическая структура создается во время операции форматирования (это процесс первоначальной разметки физического диска).
Файлы на диске располагаются по мере их поступления на свободные места. Минимальная логическая единица выделяемого дискового пространства – кластер. Разбиение на кластеры происходит во время форматирования. Кластер содержит несколько физических секторов. Величина кластера варьирует в зависимости от размеров жесткого диска и от вида файловой системы (которая размещает данные на диске и входит в состав операционной системы).

## 17. Алгоритма доступа к внешней памяти

Все алгоритмы распределения памяти можно разделить на два класса: алгоритмы, в которых используется перемещение сегментов процессов между оперативной памятью и диском, и алгоритмы, в которых внешняя память не привлекается.

Одиночное непрерывное распределение памяти

Одиночное непрерывное распределение – это самая простая схема, согласно которой вся память условно может быть разделена на три части:1) область, занимаемая операционной системой;2) область, в которой размещается исполняемая задача;3) незанятая ничем (свободная) область памяти. Программные модули, необходимые для всех программ, располагаются в области самой ОС, а вся оставшаяся память может быть предоставлена задаче. Чтобы для задач отвести как можно больший объем памяти, операционная система строится таким образом, что постоянно в оперативной памяти располагается только самая нужная ее часть. Эту часть ОС стали называть ядром. Остальные модули ОС могут быть обычными диск-резидентными (или транзитными), т. е. загружаться в оперативную память только по необходимости и после своего выполнения вновь освобождать память.

Распределение памяти разделами с фиксированными границами

Простейший способ управления оперативной памятью состоит в том, что память разбивается на несколько областей фиксированной величины, называемых раз-делами. Такое разбиение может быть выполнено вручную оператором во время старта системы или во время ее установки. После этого границы разделов не из-меняются.

## 18. Логическая структура данных на жестком диске

Кроме того, что накопитель должен быть сконфигурирован в CMOS, его логическую структуру должна понимать операционная система. Для обращения к информации используется кластер (allocation unit) – минимальная логическая единица доступа к информации. Каждый кластер состоит из нескольких секторов (8 и более). Каждый кластер пронумерован и может быть либо свободен, либо монопольно занят для хранения определенного файла, даже если не все сектора внутри его заняты. Следовательно, даже файл размером несколько байт требует целого кластера. В результате, на каждом файле теряется около половины кластера. Чем больше размер кластера, тем больше потери. Использование кластеров позволяет ускорить работу, так количество кластеров существенно меньше количества секторов.
Нумерация кластеров не соответствует их порядковому расположению на дисках. При работе используется тот факт, что при записи данных используются все сектора, которые на данный момент находятся под всеми головками, таким образом, заполняется цилиндр. Прежде чем перейти к следующему цилиндру, заполняется текущий чтобы иметь возможность считывать как можно больше информации без перемещения головок.
Для DOS версии 3.0 и выше используется алгоритм следующего свободного кластера размещения файлов на диске. Кластеры устроены так, что каждый из них ссылается на последующий. При работе DOS ищет свободные кластеры не с начала диска, а с места последней записи на диск. DOS устанавливает указатель последнего записанного кластера и ищет свободные кластеры, пользуясь этим указателем. Указатель размещается в RAM и уничтожается при перезарузке. Если DOS дошла до конца диска, то указатель также удаляется, а поиск начинается с начала диска. Таким образом осуществляются операции файлами на диске.
Этот алгоритм позволяет восстанавливать удаленные файлы. При удалении файла в начало его первого кластера ставится знак «?», и все кластеры, связанные с данным считаются свободными. Указатель выставляется на следующий свободный кластер, запись продолжается в идущих далее свободных кластерах. Перезапись кластера, в котором произошло удаление, произойдет только когда указатель в новом цикле дойдет до данного кластера. Даже, если переписывается один файл поверх другого, то запись работает по такой же схеме. А для каждого нового файла используется первая свободная запись.

## 19. Алгоритм загрузка ОС с жесткого диска

Операционная система хранится во внешней памяти обычно на жестком диске, реже – на гибком. Для нормальной работы компьютера необходимо, чтобы основные модули операционной системы находились в оперативной памяти. Поэтому после включения компьютера организована автоматическая перезапись (загрузка) операционной системы с диска в оперативную память.

<img src=images/Q19.gif width=100%>

Загрузка операционной системы– перезапись операционной системы с диска (жесткого или гибкого) в оперативную память.
После включения компьютера вы наблюдаете за сменой цифр на экране. Эти цифры отображают процесс тестирования оперативной памяти программой BIOS. При обнаружении неисправности в ячейках оперативной памяти будет выдано сообщение.
После успешного окончания тестирования аппаратуры производится обращение к дисководу с гибким диском А, и рядом с ним загорается лампочка индикации. Если вы загружаете операционную систему с гибкого диска, то надо до или во время тестирования вставить системный диск в дисковод А. В противном случае при отсутствии на диске А операционной системы осуществляется обращение к жесткому диску, о чем свидетельствует засветившаяся рядом с ним лампочка индикации.
Начинается считывание в оперативную память 0-го сектора 0-й стороны диска, в котором находится загрузчик (BOOT RECORD). Управление передается загрузчику, который проверяет наличие на системном диске модуля расширения IO.SYS и базового модуля MSDOS.SYS. Если они находятся в отведенном для них месте (см. рис. 9.10), то он загружает их в оперативную память, в противном случае будет выдано сообщение об их отсутствии. В этом случае рекомендуется произвести повторную загрузку. Сигнал повторной загрузки передает управление постоянному модулю BIOS, который снова переписывает с диска в оперативную память блок начальной загрузки и т.д.
После успешно выполненной загрузки в оперативную память модуля расширения IO.SYS и базового модуля MSDOS.SYS загружается командный процессор СОМMAND.COM и обрабатывается файл конфигурации CONFIG.SYS, который содержит команды подключения необходимых драйверов. Этот файл может отсутствовать, если вас устраивает базовый вариант операционной системы.
Затем выполняется обработка командного файла AUTOEXEC.BAT. С помощью этого файла вы можете произвести настройку параметров операционной среды. Например, создать виртуальный диск, обеспечить смену режимов печати, загрузить вспомогательные программы и т.д.
Файл со стандартным именем AUTOEXEC.BAT отличается от других файлов типа .ВАТ тем, что выполнение помещенных в него команд начинается автоматически сразу после загрузки операционной системы.
В случае отсутствия файла AUTOEXEC.BAT вам будет предложено ввести дату и время:
если вы нажмете клавишу ввода, то в качестве текущих даты и времени будут приняты так называемые системные параметры, которые определяет компьютерный таймер;
После окончания работы файла AUTOEXEC.BAT, а также если этот файл не обнаружен, на экран дисплея будет выдано приглашение системного диска, например C:\>.Это является свидетельством нормального завершения процесса загрузки, и вы можете приступить к работе, введя имя прикладной программы или команду операционной системы.

## 20. Назначение, возможности и функции файловой системы

Файловая система - это часть операционной системы, назначение которой состоит в том, чтобы организовать эффективную работу с данными, хранящимися во внешней памяти, и обеспечить пользователю удобный интерфейс при работе с такими данными.
Непосредственное взаимодействие с диском - прерогатива компонента системы ввода-вывода ОС, называемого драйвером диска. Для того чтобы избавить пользователя компьютера от сложностей взаимодействия с аппаратурой, была придумана ясная абстрактная модель файловой системы. Операции записи или чтения файла концептуально проще, чем низкоуровневые операции работы с устройствами.
Перечислим основные функции файловой системы.
1. Идентификация файлов. Связывание имени файла с выделенным ему пространством внешней памяти.
2. Распределение внешней памяти между файлами. Для работы с конкретным файлом пользователю не требуется иметь информацию о местоположении этого файла на внешнем носителе информации. Например, для того чтобы загрузить документ в редактор с жесткого диска, нам не нужно знать, на какой стороне какого магнитного диска, на каком цилиндре и в каком секторе находится данный документ.
3. Обеспечение надежности и отказоустойчивости. Стоимость информации может во много раз превышать стоимость компьютера.
4. Обеспечение защиты от несанкционированного доступа.
5. Обеспечение совместного доступа к файлам, так чтобы пользователю не приходилось прилагать специальных усилий по обеспечению синхронизации доступа.
6. Обеспечение высокой производительности.
Иногда говорят, что файл - это поименованный набор связанной информации, записанной во вторичную память. Для большинства пользователей файловая система - наиболее видимая часть ОС. Она предоставляет механизм для онлайнового хранения и доступа как к данным, так и к программам для всех пользователей системы. С точки зрения пользователя, файл - единица внешней памяти, то есть данные, записанные на диск, должны быть в составе какого-нибудь файла.

## 21. Способы форматирования файлов

Быстрое форматирование — в данном случае пространство на накопитель записывается загрузочный сектор и пустая таблица выбранной файловой системы (FAT32, NTFS, ExFAT). Пространство на диске помечается как неиспользуемое, без фактического удаления данных на нём. Быстрое форматирование занимает значительно меньше времени (в сотни-тысячи раз) чем полное форматирование того же накопителя.

Полное форматирование — при полном форматировании диска или флешки, помимо указанных выше действий выполняется также запись нулей (т.е. очистка) во все секторы диска (начиная с Windows Vista), а также производится

проверка накопителя на наличие поврежденных секторов при наличии которых они исправляются или помечаются соответствующим образом во избежание записи на них в дальнейшем. Занимает действительно продолжительное время, особенно для объемных HDD. 

## 22. Организация файлов с помощью таблиц поблочного отображения

Механизм динамического преобразования адресов должен вести таблицы, показывающие, какие ячейки виртуальной памяти в текущий момент времени находятся в реальной памяти и где именно они размещаются. Если бы такое отображение осуществлялось пословно или побайтно, то информация об отображении была бы столь велика, что для ее хранения потребовалось бы столько же или даже больше реальной памяти, чем для самих процессов. Поэтому, чтобы реализация виртуальной памяти имела смысл, необходим метод, позволяющий существенно сократить объем информации отображения.

Поскольку мы не можем идти на индивидуальное отображение элементов информации, мы группируем их в блоки, и система следит за тем, в каких местах реальной памяти размещаются различные блоки виртуальной памяти. Чем больше размер блока, тем меньшую долю емкости реальной памяти приходится затрачивать на хранение информации отображения.

Увеличение размера блоков приводит к уменьшению дополнительных затрат памяти для механизма отображения. Однако крупные блоки требуют большего времени на обмен между внешней и первичной памятью и с большей вероятностью ограничивают количество процессов, которые могут совместно использовать первичную память.

## 23. Файловая система FAT32

Она была создана, чтобы преодолеть ограничения на размер тома в FAT16, позволяя при этом использовать старый код программ MS-DOS и сохранив формат. FAT32 использует 32-разрядную адресацию кластеров.
Максимально возможное число кластеров в FAT32 равно 268 435 445, что позволяет использовать тома (логические диски) объёмом до 8 TiB. Фактически максимальный размер всего диска не может быть более 2 TiB[1]. Размер кластера по умолчанию для файловой системы FAT32 составляет от 512 байт до 32 КБ в зависимости от размера тома и конкретной версии ОС[2]. При использовании размера кластера, равного 32768 байт, максимальный размер тома составит чуть менее 8 ТБ[3]. Хотя размер сектора может быть любым, традиционно он считается равным 1 сектору диска и равен 512 байт и так как эта величина не менялась с момента создания — она может считаться некоторым ПО как константа. Это может вызвать некоторые проблемы совместимости. 
Максимально возможный размер файла для тома FAT32 — ~ 4 ГБ — 4 294 967 295 байт (в FAT32 под размер файла отведено 4 байта: это 32 бита. 232−1 — 4 294 967 295 байт. Хотя цепочку в FAT таблице можно продолжать и дальше, но тогда для определения размера файла придется каждый раз пробегать по всей цепочке, а это будет занимать много времени. К тому же в FAT таблице указаны только номера кластеров, поэтому тогда можно будет узнать только округлённое значение длины файла) — это весьма важный фактор для смены файловой системы. 
FAT32 не поддерживает установку разрешений на доступ к файлам и папкам и некоторые другие функции современных файловых систем.

## 24. Файловая система NTFS

Ограничения размера диска: в теории 264 байт (16 ЭиБ или 18 446 744 073 709 551 616 байт) на практике 255 тб 
Ограничения размера тома: теоретически — 264 — 1 кластер; 
практически - 255 тб: 232 (максимальное количество адресуемых кластеров) * 64кб (максимальный размер кластера). 
минимальный размер тома: 8 МиБ
минимальный рекомендуемый размер тома: 10 МиБ

## 25. Принципы построения ОС

1. Частотный принцип. 
Этот принцип основан на выделении в алгоритмах программ и в обрабатываемых массивах действий и данных по частоте их использования. Действия и данные, используемые часто, располагаются в оперативной памяти, т.к. к ним необходим быстрый доступ. К тому же стремятся наиболее часто выполняемые операции оптимизировать по времени выполнения и по занимаемой памяти.
Следствия от применения частотного принципа – это применение многоуровневого планирования при организации работы ОС. На уровень долгосрочного планирования выносятся редкие и длинные операции управления деятельностью системы. Краткосрочному планированию подвергаются часто используемые и короткие операции.
2. Принцип модульности.
Это принцип в равной степени отражает технологические и эксплуатационные свойства. Наибольший эффект от его использования достигается в том случае, когда принцип одновременно распространен на ОС, аппаратуру и прикладные программы.
Под модулем в общем случае понимают функциональный элемент рассматриваемой системы, имеющей законченное оформление и выполненный в пределах требования ОС, а также средства сопряжения с подобными элементами или элементами более высокого уровня данной или другой системы.
Модуль предполагает лёгкий способ его замены на другой модуль, при наличии заданных интерфейсов. Чаще всего разделение на модули происходит по функциональному признаку.
Модули могут быть восстанавливаемыми и невосстанавливаемыми. Если модуль после окончания работы не восстанавливается в исходное состояние, то он называется однократным. Если модуль в процессе работы искажает своё состояние, но перед окончанием работы восстанавливается в исходное состояние, то его называют многократным. Особое значение при построении ОС имеют модули, называемые параллельно используемыми или реентерабельными. Каждый такой модуль может использоваться одновременно несколькими программами. Это позволяет хранить в памяти только одну копию такого модуля.



3. Принцип функциональной избирательности.
В ОС выделяется некоторая часть особо важных модулей, которые должны быть в оперативной памяти постоянно для эффективной организации вычислительного процесса. Эту часть обычно называют ядром ОС.
При формировании ядра необходимо удовлетворить двум противоречивым требованиям:


– в состав ядра должны войти наиболее часто используемые модули;
– количество модулей должно быть таким, чтобы не занимать много оперативной памяти;
В состав ядра входят модули по управлению системой прерываний, средства перевода процессов с одного состояния в другое, средства распределения оперативной памяти. Программы, входящие в состав ядра, обычно загружаются в оперативную память и называются резидентными.
Помимо резидентных программ существуют транзитные модули или программы, которые загружаются только при необходимости и могут перекрывать в оперативной памяти друг друга.
4. Принцип генерируемости. 
Определяет такой способ исходного представления ОС, который позволял бы настраивать эту системную программу, исходя из конкретной конфигурации используемой машины и круга решаемых задач.
Процедура генерации проводится достаточно редко, а процесс генерации осуществляется с помощью специальной программы-генератора и входного языка для неё, позволяющего описывать программные возможности системы и конфигурацию машины. В результате генерации получается полная версия ОС. Исходный набор программ ОС, из которого производится генерация называется дистрибутивом.
5. Принцип функциональной избыточности.
Предполагает возможность проведения одной и той же работы различными средствами, т.е. ОС допускает альтернативное выполнение одних и тех же заданий в различных режимах своего функционирования.
6. Принцип по умолчанию.
Принцип основан на хранении в системе некоторых базовых описании, структур процесса, модулей, конфигурации оборудования и данных, определяющих прогнозируемые объемы требуемой памяти, времени счета программы, потребности во внешних устройствах, которые характеризуют пользовательские программы и условия их выполнения.
Эту информацию пользовательская система использует в качестве заданной, если она не будет определена или сознательно конкретизирована. В целом применение этого принципа позволяет сократить число параметров, устанавливаемых пользователем, когда он работает с системой.
7. Принцип перемещаемости.
Предусматривает построение модулей таким образом, что их исполнение не зависит от места расположения в оперативной памяти. Настройка текста модуля в соответствии с его расположением в памяти осуществляется специальными механизмами либо непосредственно пред выполнением программы, либо по мере по мере ее выполнения.
Настройка заключается в определении фактических адресов, используемых в адресных частях команды, и определяется применяемым в конкретной машине способом адресации и алгоритмом распределения оперативной памяти, принятым для данной ОС.
Этот принцип целесообразно распространять и на пользовательские программы.
8. Принцип защиты.
Определяет необходимость разработки мер, ограждающих программы и данные пользователя от искажения и нежелательного влияния друг на друга, а также пользователя на ОС и наоборот. Особенно трудно обеспечить защиту, когда используется разделение ресурсов.
Программы должны быть гарантированно защищены как при выполнении, так и при хранении, хотя попыток испортить и нанести нежелательный эффект пользовательским программам совершается множество.
Реализуется несколько подходов для обеспечения защиты.
Одним из направлений является реализация двухконтекстности работы процессора: в каждый момент времени процессор может выполнять программу из состава ОС либо прикладную или служебную программу, не входящую в состав ОС.
Второе направление состоит в том, чтобы гарантировать невозможность непосредственного доступа к любому разделяемому ресурсу со стороны пользовательских и служебных программ, для чего в состав машинных команд вводятся специальные привилегированные команды, управляющие распределением и использованием ресурсов. Такие команды разрешается выполнять только ОС. Контроль за выполнением привилегированных команд производится аппаратно.
Для реализации принципов защиты может использовать контекстный механизм защиты данных и текста программ, находящийся в операционной памяти. Для программ пользователей выделяются определенные участки памяти и выход за пределы этих участков приводит к возникновению прерываний по защите. Механизм контроля реализуется аппаратным способом, путем применения ограничительных регистров или ключей памяти.
Третье направление реализует механизм защиты данных, хранящихся в памяти, используются подходы, основанные на разграничении прав доступа, введении паролей, контроле за правильной интерпретацией данных, записанных в файле.
9. Принцип независимости программ от внешних устройств.
Позволяет выполнять операции управления внешними устройствами независимо от их конкретных физических характеристик. Связь программ с конкретными устройствами производится не на уровне трансляции программ, а в период планирования ее выполнения. При подключении новых устройств или замене существующих, текст программ не изменяется, а осуществляется подключение нового устройства к ОС путём подключения специальной программы, обеспечивающей взаимодействие ОС с внешним устройством. Такие программы называются драйверами.
10. Принцип открытой и наращиваемой операционной системы.
Открытая ОС доступна пользователю и специалисту, обслуживающему машину, а возможность наращивания или модификации операционной системы позволяет использовать не только возможности генерации, но вводить в операционную систему новые модули или модифицировать существующие.


## 26. Многослойная организация ОС

Многослойная структура ОС
 
Вычислительную систему, работающую под управлением ОС на основе ядра, можно рассматривать как систему, состоящую из трех иерархически расположенных слоев: нижний слой образует аппаратура, промежуточный — ядро, а утилиты, обрабатывающие программы и приложения, составляют верхний слой системы. Слоистую структуру вычислительной системы принято изображать в виде системы концентрических окружностей, иллюстрируя тот факт, что каждый слой может взаимодействовать только со смежными слоями. Действительно, при такой организации ОС приложения не могут непосредственно взаимодействовать с аппаратурой, а только через слой ядра.



Многослойный подход является универсальным и эффективным способом декомпозиции сложных систем любого типа, в том числе и программных. В соответствии с этим подходом система состоит из иерархии слоев. Каждый слой обслуживает вышележащий слой, выполняя для него некоторый набор функций, которые образуют межслойный интерфейс. На основе функций нижележащего слоя следующий (вверх по иерархии) слой строит свои функции — более сложные и более мощные, которые, в свою очередь, оказываются примитивами для создания еще более мощных функций вышележащего слоя. Строгие правила касаются только взаимодействия между слоями системы, а между модулями внутри слоя связи могут быть произвольными. Отдельный модуль может выполнить свою работу либо самостоятельно, либо обратиться к другому модулю своего слоя, либо обратиться за помощью к нижележащему слою через межслойный интерфейс.
 
Такая организация системы имеет много достоинств. Она существенно упрощает разработку системы, так как позволяет сначала определить «сверху вниз» функции слоев и межслойные интерфейсы, а затем при детальной реализации постепенно наращивать мощность функций слоев, двигаясь «снизу вверх». Кроме того, при модернизации системы можно изменять модули внутри слоя без необходимости производить какие-либо изменения в остальных слоях, если при этих внутренних изменениях межслойные интерфейсы остаются в силе.

<img src=images/Q26_1.png width=100%>

Рис. Концепция многослойного взаимодействия
 
Поскольку ядро представляет собой сложный многофункциональный комплекс, то многослойный подход обычно распространяется и на структуру ядра.
 
Ядро может состоять из следующих слоев:
 

<img src=images/Q26_2.png width=100%>

Рис. Многослойная структура ОС
 
В данной схеме выделены следующие слои.
Средства аппаратной поддержки ОС. Значительная часть функций ОС может выполняться аппаратными средствами [10]. Чисто программные ОС сейчас не существуют. Как правило, в современных системах всегда есть средства аппаратной поддержки ОС, которые прямо участвуют в организации вычислительных процессов. К ним относятся: система прерываний, средства поддержки привилегированного режима, средства поддержки виртуальной памяти, системный таймер, средства переключения контекстов процессов (информация о состоянии процесса в момент его приостановки), средства защиты памяти и др.
Машинно-зависимые модули ОС. Этот слой образует модули, в которых отражается специфика аппаратной платформы компьютера. Назначение этого слоя – "экранирование" вышележащих слоев ОС от особенностей аппаратуры (например, Windows 2000 – это слой HAL (Hardware Abstraction Layer), уровень аппаратных абстракций).
Базовые механизмы ядра. Этот слой модулей выполняет наиболее примитивные операции ядра: программное переключение контекстов процессов, диспетчерскую прерываний, перемещение страниц между основной памятью и диском и т.п. Модули этого слоя не принимают решений о распределении ресурсов, а только обрабатывают решения, принятые модулями вышележащих уровней. Поэтому их часто называют исполнительными механизмами для модулей верхних слоев ОС.
Менеджеры ресурсов. Модули этого слоя выполняют стратегические задачи по управлению ресурсами вычислительной системы. Это менеджеры (диспетчеры) процессов ввода-вывода, оперативной памяти и файловой системы. Каждый менеджер ведет учет свободных и используемых ресурсов и планирует их распределение в соответствии запросами приложений.
Интерфейс системных вызовов. Это верхний слой ядра ОС, взаимодействующий с приложениями и системными утилитами, он образует прикладной программный интерфейс ОС. Функции API, обслуживающие системные вызовы, предоставляют доступ к ресурсам системы в удобной компактной форме, без указания деталей их физического расположения.

## 27. Состав и функции ядра ОС

Ядро́ (англ. kernel) — центральная часть операционной системы (ОС), обеспечивающая приложениям координированный доступ к ресурсам компьютера, таким как процессорное время, память, внешнее аппаратное обеспечение, внешнее устройство ввода и вывода информации. Также обычно ядро предоставляет сервисы файловой системы и сетевых протоколов. 
Типы архитектур ядер операционных систем
Монолитное ядро
Основная статья: Монолитное ядро
Монолитное ядро предоставляет богатый набор абстракций оборудования. Все части монолитного ядра работают в одном адресном пространстве. Это такая схема операционной системы, при которой все компоненты её ядра являются составными частями одной программы, используют общие структуры данных и взаимодействуют друг с другом путём непосредственного вызова процедур. Монолитное ядро — старейший способ организации операционных систем. Примером систем с монолитным ядром является большинство UNIX-систем. 
    • Достоинства: Скорость работы, упрощённая разработка модулей. 
    • Недостатки: Поскольку всё ядро работает в одном адресном пространстве, сбой в одном из компонентов может нарушить работоспособность всей системы.
Примеры: Традиционные ядра UNIX (такие как BSD), Linux; ядро MS-DOS, ядро KolibriOS. 
Некоторые старые монолитные ядра, в особенности систем класса UNIX/Linux, требовали перекомпиляции при любом изменении состава оборудования. Большинство современных ядер позволяют во время работы подгружать модули, выполняющие часть функций ядра. В этом случае компоненты операционной системы являются не самостоятельными модулями, а составными частями одной большой программы, называемой монолитным ядром (monolithic kernel), которое представляет собой набор процедур, каждая из которых может вызвать каждую. Все процедуры работают в привилегированном режиме. 
Модульное ядро
Основная статья: Модульное ядро
Модульное ядро — современная, усовершенствованная модификация архитектуры монолитных ядер операционных систем. 
В отличие от «классических» монолитных ядер, модульные ядра, как правило, не требуют полной перекомпиляции ядра при изменении состава аппаратного обеспечения компьютера. Вместо этого модульные ядра предоставляют тот или иной механизм подгрузки модулей ядра, поддерживающих то или иное аппаратное обеспечение (например, драйверов). При этом подгрузка модулей может быть как динамической (выполняемой «на лету», без перезагрузки ОС, в работающей системе), так и статической (выполняемой при перезагрузке ОС после переконфигурирования системы на загрузку тех или иных модулей). 
Микроядро
Основная статья: Микроядро
Микроядро предоставляет только элементарные функции управления процессами и минимальный набор абстракций для работы с оборудованием. Бо́льшая часть работы осуществляется с помощью специальных пользовательских процессов, называемых сервисами. Решающим критерием «микроядерности» является размещение всех или почти всех драйверов и модулей в сервисных процессах, иногда с явной невозможностью загрузки любых модулей расширения в собственно микроядро, а также разработки таких расширений. 
    • Достоинства: Устойчивость к сбоям оборудования, ошибкам в компонентах системы. Основное достоинство микроядерной архитектуры — высокая степень модульности ядра операционной системы. Это существенно упрощает добавление в него новых компонентов. В микроядерной операционной системе можно, не прерывая её работы, загружать и выгружать новые драйверы, файловые системы и т. д. Существенно упрощается процесс отладки компонентов ядра, так как новая версия драйвера может загружаться без перезапуска всей операционной системы. Компоненты ядра операционной системы ничем принципиально не отличаются от пользовательских программ, поэтому для их отладки можно применять обычные средства. Микроядерная архитектура повышает надежность системы, поскольку ошибка на уровне непривилегированной программы менее опасна, чем отказ на уровне режима ядра. 
    • Недостатки: Передача данных между процессами требует накладных расходов.
Классические микроядра предоставляют лишь очень небольшой набор низкоуровневых примитивов, или системных вызовов, реализующих базовые сервисы операционной системы. 
    • Сервисные процессы (в принятой в семействе UNIX терминологии — «демоны») активно используются в самых различных ОС для задач типа запуска программ по расписанию (UNIX и Windows NT), ведения журналов событий (UNIX и Windows NT), централизованной проверки паролей и хранения пароля текущего интерактивного пользователя в специально ограниченной области памяти (Windows NT). Тем не менее, не следует считать ОС микроядерными только из-за использований такой архитектуры.
Примеры: Symbian OS; Windows CE; OpenVMS; Mach, используемый в GNU/Hurd и Mac OS X; QNX; AIX; Minix; ChorusOS; AmigaOS; MorphOS. 
Экзоядро
Основная статья: Экзоядро
Экзоядро — ядро операционной системы, предоставляющее лишь функции для взаимодействия между процессами, безопасного выделения и освобождения ресурсов. Предполагается, что API для прикладных программ будут предоставляться внешними по отношению к ядру библиотеками (откуда и название архитектуры). 
Возможность доступа к устройствам на уровне контроллеров позволит эффективней решать некоторые задачи, которые плохо вписываются в рамки универсальной ОС, например, реализация СУБД будет иметь доступ к диску на уровне секторов диска, а не файлов и кластеров, что положительно скажется на быстродействии. 
Наноядро
Основная статья: Наноядро
Наноядро — архитектура ядра операционной системы, в рамках которой крайне упрощённое и минималистичное ядро выполняет лишь одну задачу — обработку аппаратных прерываний, генерируемых устройствами компьютера. После обработки прерываний от аппаратуры наноядро, в свою очередь, посылает информацию о результатах обработки (например, полученные с клавиатуры символы) вышележащему программному обеспечению при помощи того же механизма прерываний. Примером является KeyKOS — самая первая ОС на наноядре. Первая версия вышла ещё в 1983 году. 
Гибридное ядро
Основная статья: Гибридное ядро
Гибридные ядра — это модифицированные микроядра, позволяющие для ускорения работы запускать «несущественные» части в пространстве ядра. Пример: ядра ОС Windows семейства NT. 


## 28. Версии ОС MS WINDOWS


0 ноября 1985 
Windows 1.0x 
1.04 (апрель 1987) 
31 декабря 2001 
Нет браузеров 
Оболочка для MS-DOS 
1 ноября 1987 
Windows 2.x
Windows 2.1x 
2.11 (13 марта 1989) 
31 декабря 2001 


22 мая 1990 
Windows 3.x 
3.00a (31 октября 1990) 
31 декабря 2001 [4] 


18 марта 1992 
Windows 3.1 
3.1 
31 декабря 2001 
Internet Explorer 5 

1 октября 1992 
Windows для рабочих групп 3.1 
3.11 (31 декабря 1993) 
31 декабря 2001 


27 июля 1993 
Windows NT 3.1 
3.10.528 SP3 (10 ноября 1994) 
31 декабря 2001 

Windows NT 
21 сентября 1994 
Windows NT 3.5 
3.50.807 SP3 (21 июня 1995) 
31 декабря 2001 


30 мая 1995 
Windows NT 3.51 
3.51.1057 SP5 (19 сентября 1996) 
31 декабря 2001 


24 августа 1995 
Windows 95 
4.00.950C (4.03.1214) (26 ноября 1997) 
31 декабря 2000 (осн.) (Retail)
31 декабря 2001 (SBL) (ext) 
Internet Explorer 5.5 
Windows 9x 
29 июля 1996 
Windows NT 4.0 
4.00.1381 / SP6a SRP (26 июля 2001) 
20 июня 2002 (осн.)
30 июня 2003 (SBL)
31 декабря 2004 (ext) 
Internet Explorer 6 
Windows NT 
25 июня 1998 
Windows 98 
4.10.2222A (SE) (5 мая 1999) 
30 июня 2002 (осн.)
31 марта 2004 (SBL)
11 июля 2006 (ext) 

Windows 9x 
20 апреля 2000 
Windows 2000 
5.0.2195 / 5.0 SP4 Rollup 1 v2 (13 сентября 2005) 
31 марта 2004 (retail)
31 марта 2005 (SBL)
30 июня 2005 (осн)
13 июля 2010 (ext) 

Windows NT 
14 сентября 2000 
Windows ME 
4.90.3000 (14 сентября 2000) 
31 декабря 2003 (осн.)
30 июня 2004 (SBL) (Retail)
11 июля 2006 (ext) 

Windows 9x 
24 августа 2001 (RTM)
25 октября 2001 (продажи) 
Windows XP 
5.1.2600.5512 SP3 (21 апреля 2008) 
30 сентября 2004 (RTM)
10 сентября 2006 (SP1/SP1a)
30 июня 2008 (retail)
14 апреля 2009 (SP2/SP3 осн.)
13 июля 2010 (SP2)
22 октября 2010 (SBL)
8 апреля 2014 (ext) 
Internet Explorer 8 
Windows NT 
28 марта 2003 
Windows XP 64-bit Edition 
5.2.3790 
25 июля 2006 


24 апреля 2003 
Windows Server 2003 
5.2.3790.3959 SP2 (13 марта 2007) 
30 июня 2009 (RTM)
13 июля 2010 (осн.)
14 июля 2015 (ext) 

Windows Server 
25 апреля 2005 
Windows XP Professional x64 Edition 
5.2.3790.3959 SP2 (13 марта 2007) 
30 июня 2008 (retail)
31 января 2009 (SBL) 

Windows NT 
8 ноября 2006 (RTM)
30 января 2007 (продажи) 
Windows Vista 
6.0.6001 / SP2 Build 6002 (25 мая 2009) 
13 апреля 2010 (RTM)
22 октября 2010 (retail)
12 июля 2011 (SP1)
22 октября 2011 (SBL)
10 апреля 2012 (осн.)
11 апреля 2017 (ext) 
Internet Explorer 9 

16 июля 2007 
Windows Home Server 
5.2.4500 (16 июля 2007) 
8 января 2013 (ext) 

Windows Server 
27 февраля 2008 
Windows Server 2008 
6.0.6002 / SP2 build 6002 (25 мая 2009) 
12 июля 2011 (SP1)
13 января 2015 (осн)
14 января 2020 (ext) 


13 июля 2009 (RTM)
22 октября 2009 (продажи) 
Windows 7 
6.1.7601 / SP1 Build 7601 (22 февраля 2011) 
9 апреля 2013 (RTM)
13 января 2015 (осн)
14 января 2020 (ext) 
Internet Explorer 11 
Windows NT 
13 июля 2009 (RTM)
22 октября 2009 (продажи) 
Windows Server 2008 R2 или Windows Server 7 
6.1.7601 / SP1 Build 7601 (22 февраля 2011) 
13 января 2015 (осн)
14 января 2020 (ext) 

Windows Server 
6 апреля 2011 
Windows Home Server 2011 
6.1.8400 
12 апреля 2016 (ext) 


1 августа 2012 (RTM)
4 сентября 2012 (продажи) 
Windows Server 2012 
6.2.9200 (26 октября 2012) 
9 октября 2018 (осн)
10 октября 2023 (ext) 


1 августа 2012 (RTM)
26 октября 2012 (продажи) 
Windows 8 
6.2.9200 (26 октября 2012) 
12 января 2016 (ext) 

Windows NT 
21 августа 2013 (RTM)
17 октября 2013 (продажи) 
Windows Server 2012 R2 
6.3.9600 (17 октября 2013) 
9 января 2018 (осн)
10 января 2023 (ext) 

Windows Server 
21 августа 2013 (RTM)
17 октября 2013 (продажи) 
Windows 8.1 
6.3.9600 (17 октября 2013) 
9 января 2018 (осн)
10 января 2023 (ext) 

Windows NT 
15 июля 2015 (RTM)
29 июля 2015 (продажи) 
Windows 10 
10.0.18363.535 1909 (10 декабря 2019) 
13 октября 2020 (осн.)
14 октября 2025 (ext.) 
Microsoft Edge / Internet Explorer 11 (оставлен для совместимости) 

29 сентября 2016 (RTM)
12 октября 2016 (продажи) 
Windows Server 2016 
1607 (10.0.14393) (26 сентября 2016) 
11 января 2022 (осн.)
11 января 2027 (ext.) 
Internet Explorer 11 
Windows Server 
14 августа 2018 (RTM)
2 октября 2018 (продажи) 
Windows Server 2019 
1809 (10.0.17763) (11 ноября 2018) 





## 29. ОС MS WINDOWS. Основные команды

FORMAT [<ИМЯ ДИСКОВОДА>][/V][/S]
По команде format форматируется диск на дисководе, имя которого указано, если
имя не указано, то форматируется диск в текущем или активном дисководе.
/v - дает возможность записать на диск его метку или название (volume label).
/s - переносит на диск операционную систему.

MKDIR или MD (make directory) - создание каталога или директории.
Формат команды :
MD [<имя дисковода>:][<маршрут>]<имя каталога>

При использовании многоуровневых каталогов часто возникает необходимость в
переходе из текущего каталога в тот, в котором необходимо продолжить работу. Для этой
цели применяется команда CHDIR или CD (change directory) - смена каталога.
Формат команды:
CD <маршрут>
Необходимо заметить, что с помощью команды CD нельзя перейти на другой диск.
Существует один дополнительный формат команды CD
CD..
С помощью такой команды можно подняться из текущего (если это не корневой)

Самой простой является команда просмотра имен тех файлов, которые есть в
каталоге - команда DIR.
Формат команды:
DIR [<имя диска>][<маршрут>][<имя,тип файла>][/p][/w]
Команда позволяет посмотреть, какие файлы записаны на указанном диске в каталоге
по указанному маршруту. Для просмотра текущего каталога на текущем дисководе

Для стирания устаревших программ или ненужных данных с диска используется
команда DEL (delete) - уничтожение файлов.
Формат команды:
DEl [<имя диска>][<маршрут>][<имя и тип файла>]
С помощью этой команды происходит удаление с указанного диска и из указанного
каталога файла с заданным именем и типом. Если нужно удалить файл из текущего
каталога на текущем диске, можно указать только имя и тип стираемого файла. Место
стертого файла становится свободным для записи других файлов.
В команде DEL допустимо использование группового имени файла, что дает
возможность уничтожать группу файлов, имена которых удовлетворяют заданному
шаблону.
Команда REN (rename) - переименование - служит для изменения имени файла.
Формат команды:
REN [<имя диска>][<маршрут>]<старое имя> <новое имя>
Однако в разных каталогах могут быть файлы с одинаковыми именами.
Команда TYPE - печать служит для вывода содержимого текстового файла на экран
монитора. Эта команда неприменима к файлам, содержащим программы или двоичные
данные.
Формат команды:
TYPE <имя и тип файла>
Не разрешено использование группового имени файла. Прокрутку большого файла
на экране можно остановить с помощью клавиш CTRL-S.

Копирование файлов осуществляется по команде COPY - копирование.
Наиболее употребительный формат команды:
COPY [<имя диска>][<маршрут>]<имя копируемого файла>
[<имя диска>][<маршрут>][<имя файла>][/V][/A][/B]
По команде COPY копируются один или несколько файлов с указанного диска и
каталога на новый заданный диск и каталог. Команда COPY позволяет также
осуществлять обмен между внешними устройствами, имена которых в этом случае
указываются вместо имен файлов. С помощью команды COPY можно объединить
несколько файлов в один.
Если копируется файл с текущего дисковода и текущей директории, то первое имя
диска и маршрут можно не указывать.

## 30. ОС MS WINDOWS. Команды пакетных файлов

В пакетном файле могут использоваться операторы перенаправления для изменения
местоположений потоков ввода и вывода команд, заданных по умолчанию, на какие-либо
другие. В следующей таблице описаны операторы перенаправления потоков ввода и
вывода команд.
Оператор
перенаправления
>
<
>>
|
Описание
Записывает данные на выходе команды вместо командной строки
в файл или на устройство.
Читает поток входных данных команды из файла, а не с
клавиатуры.
Добавляет выходные данные команды в конец файла, не удаляя
при этом существующей информации из файла.
Считывает выходные данные одной команды и записывает их на
вход другой команды. Эта процедура известна под названием
«канал».
Перенаправление ввода команд (<)
Для перенаправления ввода команд с цифровой клавиатуры на файл или на устройство
используйте оператор «<». Например, чтобы команда SORT обрабатывала данные,
введенные не с клавиатуры, а из файла List.txt нужно ввести:
SORT<file.txt
Перенаправление вывода команд (>)
Выходные данные практически всех команд высвечиваются в окне командной строки. Для
перенаправления сообщений, выводимых командой при выполнении в файл или на
устройство применяется оператор «>». Этот оператор используется с большинством
команд. Например, для перенаправления вывода команды результата работы команды DIR
в файл Dirlist.txt нужно ввести:
DIR>dirlist.txt
Если файл Dirlist.txt не существует, он будет создан. Если файл существует, его
содержимое будет заменено на данные, полученные от команды DIR.
Добавления вывода команд (>>)
Для добавления выходных данных команды в конец файла без потери хранящейся в нем
информации используется двойной символ «больше» (>>). Например, следующая команда
добавляет список каталогов, созданный командой DIR, в файл Dirlist.txt:
в файл Dirlist.txt нужно ввести:
DIR>dirlist.txt
Если файл Dirlist.txt не существует, он будет создан. Если файл существует, его
содержимое будет заменено на данные, полученные от команды DIR.
Добавления вывода команд (>>)
Для добавления выходных данных команды в конец файла без потери хранящейся в нем
информации используется двойной символ «больше» (>>). Например, следующая команда
добавляет список каталогов, созданный командой DIR, в файл Dirlist.txt:
DIR>>dirlist.txt
Оператора канала (|)
Оператор канала «вертикальная линия» (|) забирает выходные данные одной команды и
направляет их на вход другой команды. Например, в команде:
dir | sort
команда sort использует выходные данные команды dir в качестве своих входных данных.
В пакетном файле в комбинации с командами часто используют специальные
средства – фильтры. Фильтры делят, переупорядочивают или выделяют отдельные части
из проходящей через них информации. В приведенной ниже таблице перечислены
команды-фильты, доступные в ОС Windows.
Коман
Описание
да
Отображает содержимое файла или вывода команды в одном окне командной
more
строки за раз.
find
Поиск указанных символов в файлах и выходе команды.
sort
Сортировка файлов и выхода команды по алфавиту.
Команда MORE
Команда more выводит содержимое файла или выхода команды в одном окне командной
строки за раз. Например, чтобы отобразить содержимое файла List.txt в одном окне
командной строки за раз, нужно ввести команду:
MORE < list.txt
Отображается одно окно командной строки со сведениями, а затем в нижней части окна
командной строки отображается строка -- More -- . Для перехода к следующему окну
командной строки, нажмите любую клавишу на клавиатуре, кроме клавиши PAUSE. Для
остановки просмотра следует ввести комбинацию CTRL+C.
Команда more полезна при работе с командами, создающими выход более одного окна
командной строки. Например, при выводе дерева каталогов жесткого диска. Если на диске
содержится больше каталогов, чем может быть одновременно выведено в окне командной
строки, можно использовать команду tree с каналом (|) и команду more.
TREE c:\ | MORE
На экран будет выведен первое окно командной строки с выходом команды tree, а затем
отобразится строка -- More -- . Выход будет ожидать нажатия любой клавиши для
продолжения (кроме клавиши PAUSE).
Команда FIND
Команда FIND проводит поиск заданной строки или текста в файлах. Команда Cmd.exe
отображает каждую строку, которая совпадает со строкой или текстом, указанным в окне
коммандной строки. Команда find может быть использована как команда-фильтр и как
обычная команда.
Чтобы использовать команду find в качестве команды-фильтра, необходимо включить
символ «меньше» (<) и строку или текст, в котором требуется выполнить поиск. По
умолчанию при поиске команда find учитывает регистр. Например, следующая команда
будет искать строку "Pacific Rim" в файле Trade.txt:
FIND "Pacific Rim" < trade.txt
Выход не включает вхождение строки "pacific rim". Встречается вхождение строки "Pacific
Rim" с прописными буквами.
Для сохранения результатов работы команды find (вместо отображения их в окне
командной строки) используется символ «больше» (>) и имя файла, в котором требуется
хранить выход. Например, следующая команда ищет строку "Pacific Rim" в файле Trade.txt
с сохранением результата в файле Nwtrade.txt:
FIND "Pacific Rim" < trade.txt > nwtrade.txt
Команда SORT
Команда sort выполняет сортировку по алфавиту текстового файла или выхода команды.
Например, следующая команда сортирует содержимое файла List.txt и отображает
результаты в окне командной строки:
SORT < list.txt
В этом примере команда sort сортирует строки файла List.txt в алфавитном порядке и
выводит результат на экран без изменения файла. Для сохранения результатов работы
команды SORT (вместо их отображения) используется символ символ «больше» (>) и имя
файла. Например, следующую команду можно использовать для алфавитной сортировки
строк файла List.txt и сохранения результатов в файле Alphlist.txt:
SORT < list.txt > alphlist.txt
Для сортировки вывода команды следует ввести команду, затем символ канала (|) и
команду SORT (команда | SORT). Например, следующая команда сортирует в алфавитном
порядке строки, которые содержат слово "Jones" (вывод команды FIND):
FIND "Jones" maillst.txt | SORT
паузой после заполнения каждого экрана.
В пакетном файле кроме команд командного процессора, имен утилит или любых
программ можно использовать команды,
предназначенные исключительно для
применения в пакетном файле и позволяющие организовать ветвления, переходы и циклы.
Команда
Назначение
===============================================================
ECHO
Переключает возможности вывода выполняемых команд
пакетного файла на экран, или отображает текущую установку.
GOTO
Обеспечивает выполнение команд, расположенных
после указанной метки.
FOR
Выполняет команду для группы файлов
Формат:
FOR %%c IN set DO команда (для пакетной обработки)
или
FOR %c IN set DO команда (для интерактивного выполнения)
Чтобы избежать конфликтов с пакетными параметрами %0 - %9, переменная «c»
может быть любым символом, за исключением 0, 1, 2, 3,...,9. set - это выражение в скобках.
Команда последовательно присваивает переменной %%c каждое значение set, чтобы
выполнить команду (команда). Если в выражении set используются шаблоны (* или ?),
переменной присваивается каждое значение, соответствующее выражению и находящееся
на диске. В таком случае set должно содержать только одно выражение, так как команда
игнорирует все выражения, кроме первого.
IF
PAUSE
REM Выполняет команду, если выполняется условие.
Приостанавливает выполнение пакетного файла.
Отображает комментарии в пакетном файле.
CALL Назначение:
Вызов одного пакетного файла из другого.
Формат:
CALL [диск:][путь]имя_файла [параметры]
Параметры:
Набор параметров командной строки, необходимых пакетному файлу.
Пример:
REM Вызываем поочередно пакетные файла
CALL ABCD.BAT
CALL NTSN.BAT
CALL REAL.BAT
REM

SHIFT
Назначение:
Позволяет изменять положение замещаемых параметров при выполнении пакетного файла
Формат:
SHIFT
Команда SHIFT используется для изменения положения (перемещаемых) параметров
командной строки. Обычно командный файл ограничен в использовании только десяти
параметров, от %0 до %9. Однако, используя команду SHIFT, можно получить доступ к
большему количеству параметров. Это значит, что если в командной строке задано более
десяти параметров, тот из них, который появляется после десятого (%9), становится %9.
Можно использовать команду SHIFT даже если параметров меньше чем десять. Обратной
команды SHIFT не существует. Однажды выполнив команду SHIFT, нельзя использовать
первый параметр (%0), который существовал до этого.

## 31. Версии ОС Linux

На сегодняшний день существует множество различных поставок Linux, ''дистрибутивов'', которые можно разделить на дистрибутивы общего назначения и специализированные. К специализированным дистрибутивам относятся такие как Linux Router — урезанная поставка Linux для создания дешевого маршрутизатора на базе старого PC идр. Не смотря на различия в дистрибутивах общего назначения, все они образуют лицо ОС Linux такой, какой ее знают большинство пользователей ОС. В отличие от ядра, дистрибутивы могут содержать коммерческие компоненты, и потому их свободное распространение может быть ограниченно. В таком случае авторы дистрибутива делают доступными все свободные компоненты. Обычно под словосочетанием "ОС Linux" понимаютдистрибутивы Linux общегоназначения. GNU/Linux работает на PC-совместимых системах семейства Intel x86, а также на IA-64, AMD64, PowerPC, ARM и многих других. К операционной системе GNU/Linux также часто относят программы, дополняющие эту операционную систему, и прикладные программы, делающие её полноценной многофункциональной операционной средой. В отличие от большинства других операционных систем, GNU/Linux не имеет единой «официальной» комплектации. Вместо этого GNU/Linux поставляется в большом количестве дистрибутивов, в которых программы GNU соединяются с ядром Linux и другими программами. Наиболее известными дистрибутивами GNU/Linux являются Ubuntu, Debian GNU/Linux, Red Hat, Fedora, Mandriva, SuSE, Gentoo, Slackware, Archlinux. Российские дистрибутивы — ALT Linux и ASPLinux. Linux использует стандартную оконную систему X. В большинстве дистрибутивов используется свободнораспространяемая реализация X'ов - Xorg. Xorg поддерживает (почти) все популярные графические адаптеры на платформе Intel и некоторых других. Оконная система X построена на клиент-серверной архитектуре, таким образом, место запуска приложения и место его отображения могут быть физически разнесены по сети. Средства разработки под X, входящие в стандарт, представляют только базовый API разработчика. Как правило, при разработке приложений используют дополнительные библиотеки для построения интерфейса. Набор интегрированных базовых приложений, построенных на одной библиотеке, образует графическую среду пользователя. Наиболее популярные графические среды сегодня - Gnome (GNU Network Object Model Environment) и KDE (K Desktop Environment).

## 32. Linux. Основные команды

1.Общие команды Linux
% uname -a % Показать версию ядра Linux;
man — вызов мануала
 % man hier % Описание иерархии файловой системы (для чегонужна каждая директория в Linux);
 % clear % Очищение экрана терминала; 
% date % Показывает текущую датуи время; 
% uptime % Показать текущее время и работу системы без перезагрузки и выключения;
 % !! % Выполнить последнюю команду;
 % poweroff % Выходиз Linux;
 % reboot % Перезагрузка системы;
 % last reboot % Cтатистика перезагрузок; 
2. Команды Linux: работы с файлами и директориями
% pwd % Выводит текущий путь;
 % ls % Выводит список файлов и каталогов по порядку;
 % ls -laX % Выводит форматированный список всех файлов и директорий, включая скрытые;
 % cd % Переход в домашнюю директорию;
 % cd /home % Переход в директорию /home;
 % touch /home/primer2 % Создание пустого файла /home/primer2;
 % cat /home/primer2 % Показать содержимое файла /home/primer2;
 % echo "Последняя строчка" | sudo tee -a /home/primer2 % Добавление к концу файла /home/primer2 строки "Последняя строчка";
 % cp /home/Mut@NT/primer.txt /home/primer.txt % Копирует  /home/Mut@NT/primer.tx в home/primer.txt;
 % ln -s /home/Mut@NT/primer.txt /home/primer % Cоздает символическую ссылку /home/primer к файлу/home/Mut@NT/primer.txt;
 % mkdir /home/Mut@NT/shaman % Создание директории с именем shaman;
 % rmdir /home/Mut@NT/shaman % Удаление директории с именем shaman;
 % rm -rf /home/Mut@NT/shaman % Удаление директории с вложенными фалами;
 % cp -la /dir1 /dir2 % Копирование директорий;
 % locate primer % Поиск всех файлов с именем primer;
3. Команды Linux: информация об устройствах.
% lsdev % информация об уже установленных устройствах (в некоторых дистрибутивах требует доставить пакет procinfo);
 % cat /proc/cpuinfo % Показать полную информацию о модели процессора (частота, поддерживаемые инструкцииит.д.);
 % watch -n1 'cat /proc/interrupts' % Показать информацию о прерываниях;
 % lshal % Показать список всех устройств и их параметров;
 % lsusb -tv % Показать обнаруженные USB-устройства;
